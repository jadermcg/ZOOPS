# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'Check if EM is converged.
#'@name hasConverged
#'@param cutoff If change is less than cutoff, EM has converged.
#'@param niter
#'@param alpha
#'@param convergence
#'@param changes
#'@return True or False dependent on whether the EM has converged or not.
NULL

#'Compute the step-size for EM convergence.
#'@name step_size
#'@param convergence Convergence vector.
#'@return The abs of difference between the 2 last positions of convercence vector.
NULL

#'Computes de complete Log-Likelihood of the data and parameters.
#'@name Q
#'@param fasta Dataset of sequences.
#'@param alpha PWM motif model.
#'@param beta Markov backround model.
#'@return The Log-Likelihood of all sequences and parameters.
Q <- function(fasta, alpha, beta) {
    .Call('_ZOOPS_Q', PACKAGE = 'ZOOPS', fasta, alpha, beta)
}

#'Computes de Log-Likelihood of the data and parameters.
#'@name LL
#'@param fasta Dataset of sequences.
#'@param alpha PWM motif model.
#'@param beta Markov backround model.
#'@return The Log-Likelihood of all sequences and parameters.
LL <- function(fasta, alpha, beta) {
    .Call('_ZOOPS_LL', PACKAGE = 'ZOOPS', fasta, alpha, beta)
}

#'Create tau-order Markov Chain from the dataset.
#'@name createMarkovChain
#'@param fasta The dataset os sequences.
#'@param tau The order of markov chain.
#'@return The Markov Model of tau-order.
createMarkovChain <- function(fasta, tau = 0L) {
    .Call('_ZOOPS_createMarkovChain', PACKAGE = 'ZOOPS', fasta, tau)
}

#'Computes de probability of a sequence give the alpha model.
#'@name probSeqGivenAlpha
#'@param kmer Sequence with k size.
#'@param alpha PWM (Position Weight Matrix) model.
#'@return The probability of sequence given the current PWM model.
probSeqGivenAlpha <- function(kmer, alpha) {
    .Call('_ZOOPS_probSeqGivenAlpha', PACKAGE = 'ZOOPS', kmer, alpha)
}

#'Computes de log-probability of a sequence give the alpha model.
#'@name probSeqGivenAlphaLog
#'@param kmer Sequence with k size.
#'@param alpha PWM (Position Weight Matrix) model.
#'@return The probability of sequence given the current PWM model.
probSeqGivenAlphaLog <- function(kmer, alpha) {
    .Call('_ZOOPS_probSeqGivenAlphaLog', PACKAGE = 'ZOOPS', kmer, alpha)
}

#'Computes de probability of a sequence give the beta model.
#'@name probSeqGivenBeta
#'@param seq Sequence with k size.
#'@param beta Markov Chain.
#'@return The probability of sequence given the Markov model. 
probSeqGivenBeta <- function(seq, beta) {
    .Call('_ZOOPS_probSeqGivenBeta', PACKAGE = 'ZOOPS', seq, beta)
}

#'Computes de probability of a sequence give the beta model.
#'@name probSeqGivenBeta
#'@param seq Sequence with k size.
#'@param beta Markov Chain.
#'@return The probability of sequence given the Markov model. 
probSeqGivenBetaLog <- function(seq, beta) {
    .Call('_ZOOPS_probSeqGivenBetaLog', PACKAGE = 'ZOOPS', seq, beta)
}

#'Computes de probability of a sequence give the position.
#'@name probSeqGivenPos
#'@param seq Sequence with k size.
#'@param alpha PWM (Position Weight Matrix) model.
#'@param beta Markov Chain.
#'@param pos Position to compute probabilities.
#'@return The probability of sequence given the position. 
probSeqGivenPos <- function(seq, alpha, beta, pos) {
    .Call('_ZOOPS_probSeqGivenPos', PACKAGE = 'ZOOPS', seq, alpha, beta, pos)
}

#'Computes de log-probability of a sequence give the position.
#'@name probSeqGivenPosLog
#'@param seq Sequence with k size.
#'@param alpha PWM (Position Weight Matrix) model.
#'@param beta Markov Chain.
#'@param pos Position to compute probabilities.
#'@return The probability of sequence given the position. 
probSeqGivenPosLog <- function(seq, alpha, beta, pos) {
    .Call('_ZOOPS_probSeqGivenPosLog', PACKAGE = 'ZOOPS', seq, alpha, beta, pos)
}

#'Compute information content.
#'@name computeIC
#'@param alpha PWM model.
#'@param beta Markov 0-order model.
#'@return Information content score.
computeIC <- function(alpha, beta) {
    .Call('_ZOOPS_computeIC', PACKAGE = 'ZOOPS', alpha, beta)
}

#'Compute information content from a uniform distribution.
#'@name computeICU
#'@param alpha PWM model.
#'@return Information content score.
computeICU <- function(alpha) {
    .Call('_ZOOPS_computeICU', PACKAGE = 'ZOOPS', alpha)
}

#'Update the alpha model with all kmers in the sequence.
#'@name soft_update
#'@param alpha PWM model.
#'@param seq All kmers in the sequence.
#'@param posteriori All kmers posteriori distribution.
soft_update <- function(alpha, seq, posteriori) {
    invisible(.Call('_ZOOPS_soft_update', PACKAGE = 'ZOOPS', alpha, seq, posteriori))
}

#'Update the alpha model with all kmers in the sequence.
#'@name hard_update
#'@param alpha PWM model.
#'@param seq All kmers in the sequence.
#'@param posteriori All kmers posteriori distribution.
hard_update <- function(alpha, seq, posteriori) {
    invisible(.Call('_ZOOPS_hard_update', PACKAGE = 'ZOOPS', alpha, seq, posteriori))
}

#'Convert kmers to PWM model.
#'@name kmers2alpha
#'@param kmers Kmers to convert.
#'@return PWM model from kmers.
kmers2alpha <- function(kmers) {
    .Call('_ZOOPS_kmers2alpha', PACKAGE = 'ZOOPS', kmers)
}

#'Convert PWM model to kmers.
#'@name alpha2kmers
#'@param alpha PWM model to convert.
#'@param fasta Dataset of sequences.
#'@return The best kmers from dataset with respect to alpha.
alpha2kmers <- function(alpha, fasta) {
    .Call('_ZOOPS_alpha2kmers', PACKAGE = 'ZOOPS', alpha, fasta)
}

#'Create random initial PWM guess from fasta.
#'@name fasta2kmers
#'@param fasta Dataset of sequences.
#'@param k Size of kmers.
#'@return The best kmers from dataset with respect to alpha.
fasta2alpha <- function(fasta, k) {
    .Call('_ZOOPS_fasta2alpha', PACKAGE = 'ZOOPS', fasta, k)
}

#'Converts char nucleotide A,C,G,T in int 0,1,2,3.
#'@name char2int
#'@param c char to convert for.
#'@return The correspondent int or throws a invalid character.
NULL

#'Converts int 0,1,2,3 to nucleotide char A,C,G,T.
#'@name int2char
#'@param i int to convert for.
#'@return The correpondent nucleotide character or throws a invalid integer.
NULL

#'Convert a kmer into a corresponding integer.
#'@name kmer2index
#'@param kmer Kmer to convert for.
#'@return A corresponding index to kmer.
NULL

#'Convert a integer to corresponding kmer.
#'@name index2kmer
#'@param index Index to converting for.
#'@param k The size of kmer.
#'@return The corresponding kmer.
NULL

#'Computes fast log2 function.
#'@name fastlog2
#'@param x A positive double value.
#'@return Fast log2 of x.
NULL

#'Computes a log fast log function.
#'@name fastlog.
#'@param x A positive double value.
#'@return Fast Log of x.
NULL

#'Computes hamming distance for two strings.
#'@name hamming_distance_parallel
#'@param str1 The first string.
#'@param str2 The second string.
#'@return The hamming distance between str1 and str2.
NULL

#'This function computes the overlap string between two string a and b.
#'@name string_corr
#'@param a First string.
#'@param b Second string.
#'@return The correlation string between both strings a and b.
corr <- function(a, b) {
    .Call('_ZOOPS_corr', PACKAGE = 'ZOOPS', a, b)
}

#'Computes the correlation frequency from correlation string.
#'@name corr_freq
#'@param correlation_str Correlation string computed from corr.
#'@return Frenquency correlation.
corr_freq <- function(correlation_str) {
    .Call('_ZOOPS_corr_freq', PACKAGE = 'ZOOPS', correlation_str)
}

#'Computes the correlation frequency between two strings.
#'@name fast_corr_freq
#'@param a First string.
#'@param b Second string.
#'@return Frenquency correlation.
fast_corr_freq <- function(a, b) {
    .Call('_ZOOPS_fast_corr_freq', PACKAGE = 'ZOOPS', a, b)
}

#'Compute DKL between alpha and beta models. 
#'@name computeDKL
#'@param alpha PWM model.
#'@param beta 0-order Markov model.
#'@param kmer Target sequence.
#'@return Kullback-Leibler divergence between alpha and beta models.
computeDKL <- function(alpha, beta, kmer) {
    .Call('_ZOOPS_computeDKL', PACKAGE = 'ZOOPS', alpha, beta, kmer)
}

#'Compute DKL between alpha and uniform models. 
#'@name computeDKLU
#'@param alpha PWM model.
#'@param kmer Target sequence.
#'@return Kullback-Leibler divergence between alpha and uniform models.
computeDKLU <- function(alpha, kmer) {
    .Call('_ZOOPS_computeDKLU', PACKAGE = 'ZOOPS', alpha, kmer)
}

#'Compute score from PWM model. 
#'@name score
#'@param alpha PWM model.
#'@return Simple score from PWM model.
computeSCORE <- function(alpha) {
    .Call('_ZOOPS_computeSCORE', PACKAGE = 'ZOOPS', alpha)
}

#' Runs Expectation Maximization ZOOPS and reestimates model parameters.
#'@name zoops
#'@param fasta Dataset of sequences.
#'@param alpha PWM model.
#'@param beta 0-order Markov Chain.
#'@param cutoff Cutoff for EM convergence.
#'@param niter Maximum number of iterations.
#'@param w Priori probability to each sequence has a motif.
#'@return Updated PWM model.
zoops <- function(fasta, alpha, beta, cutoff, niter, w = 0.5) {
    .Call('_ZOOPS_zoops', PACKAGE = 'ZOOPS', fasta, alpha, beta, cutoff, niter, w)
}

#' Runs Expectation Maximization ZOOPS and reestimates model parameters.
#'@name logzoops
#'@param fasta Dataset of sequences.
#'@param alpha PWM model.
#'@param beta 0-order Markov Chain.
#'@param cutoff Cutoff for EM convergence.
#'@param niter Maximum number of iterations.
#'@param w Priori probability to each sequence has a motif.
#'@return Updated PWM model.
logzoops <- function(fasta, alpha, beta, cutoff, niter, w = 0.5) {
    .Call('_ZOOPS_logzoops', PACKAGE = 'ZOOPS', fasta, alpha, beta, cutoff, niter, w)
}

